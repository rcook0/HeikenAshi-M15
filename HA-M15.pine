// @version=5
// M15 Heikin Ashi Overlay Strategy — Fully self-configuring with automatic session detection and symbol-based default volatility factors

// @version=5
// M15 Heikin Ashi Strategy — Pure HA (no overlay of real candles)

strategy("M15 Heikin Ashi Strategy — Pure v1.0",
     overlay=true,
     timeframe="15",
     initial_capital=10000,
     pyramiding=0,
     process_orders_on_close=true,
     calc_on_order_fills=true,
     calc_on_every_tick=false,
     commission_type=strategy.commission.percent,
     commission_value=0.02,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=10)

//───────────────────────────────
// ⌥ Inputs
//───────────────────────────────
accuracy = input.float(0.70, "Signal accuracy (0..1)", minval=0.30, maxval=1.00, step=0.05)
relax    = 1.0 - accuracy
riskPct  = input.float(10, "Position size % of equity", minval=0.1, maxval=100)

//───────────────────────────────
// ⌥ Heikin Ashi Calculation
//───────────────────────────────
haSmoothLen = input.int(3, "HA smoothing length")
var float haCloseSmooth = na
haCloseRaw = (open + high + low + close)/4
haCloseSmooth := na(haCloseSmooth[1]) ? haCloseRaw : ta.ema(haCloseRaw, haSmoothLen)
haOpen  = na(haOpen[1]) ? (open + close)/2 : (haOpen[1] + haCloseSmooth[1])/2
haHigh  = math.max(high, math.max(haOpen, haCloseSmooth))
haLow   = math.min(low, math.min(haOpen, haCloseSmooth))

//───────────────────────────────
// ⌥ Indicators
//───────────────────────────────
lenEMAfast = input.int(21,  "EMA fast")
lenEMAslow = input.int(200, "EMA slow")
emaFast = ta.ema(haCloseSmooth, lenEMAfast)
emaSlow = ta.ema(haCloseSmooth, lenEMAslow)
vwap    = ta.vwap(hlc3)
vwapSlope = vwap - vwap[1]

useVolumeFilter = input.bool(true, "Enable volume filter")
volLen = input.int(20, "Volume MA length")
volMA  = ta.sma(volume, volLen)
volOK  = not useVolumeFilter or (volume > volMA)

//───────────────────────────────
// ⌥ Stochastic
//───────────────────────────────
kLen   = input.int(14, "Stoch K length")
dLen   = input.int(3,  "Stoch D length")
smooth = input.int(3,  "Stoch smoothing")
[k, d] = ta.stoch(haCloseSmooth, haHigh, haLow, kLen, smooth, dLen)
obase = 80.0, obMin = 60.0
osbase = 20.0, osMax = 40.0
ob = obase - (obase - obMin) * relax
os = osbase + (osMax - osbase) * relax

//───────────────────────────────
// ⌥ Entry Logic
//───────────────────────────────
nearTolBase = 0.0, nearTolMax = 5.0
nearTol = nearTolBase + (nearTolMax - nearTolBase) * relax
stochCrossUp   = ta.crossover(k, d) and k < os + nearTol
stochCrossDown = ta.crossunder(k, d) and k > ob - nearTol

bullStructure = haCloseSmooth > vwap and emaFast > emaSlow and vwapSlope > 0 and volOK
bearStructure = haCloseSmooth < vwap and emaFast < emaSlow and vwapSlope < 0 and volOK

longCond  = bullStructure and stochCrossUp
shortCond = bearStructure and stochCrossDown

//───────────────────────────────
// ⌥ ATR Management
//───────────────────────────────
atrLen = input.int(14, "ATR length")
atr    = ta.atr(atrLen)
atrPctSL = input.float(1.0, "%ATR for Stop")
atrPctTP = input.float(2.0, "%ATR for Target")
longSL  = haCloseSmooth - atr * atrPctSL
longTP  = haCloseSmooth + atr * atrPctTP
shortSL = haCloseSmooth + atr * atrPctSL
shortTP = haCloseSmooth - atr * atrPctTP

useBE   = input.bool(true)
beRR    = input.float(1.0, "Move to BE at R multiple")
beOff   = input.float(0.1, "BE offset in ATR")
useTrail= input.bool(true)
trailATR= input.float(1.5, "ATR multiple for trail")
var float longEntry = na
var float shortEntry= na
longRisk  = na(longEntry)  ? na : longEntry - longSL
shortRisk = na(shortEntry) ? na : shortSL - shortEntry
beLongPrice  = na(longEntry)  or na(longRisk)  ? na : longEntry + beOff * atr
beShortPrice = na(shortEntry) or na(shortRisk) ? na : shortEntry - beOff * atr
trailLong = haCloseSmooth - trailATR * atr
trailShort= haCloseSmooth + trailATR * atr

//───────────────────────────────
// ⌥ Orders
//───────────────────────────────
if longCond and strategy.position_size <= 0
    strategy.entry("Long", strategy.long, qty_percent=riskPct)
    longEntry := haCloseSmooth
    shortEntry := na

if shortCond and strategy.position_size >= 0
    strategy.entry("Short", strategy.short, qty_percent=riskPct)
    shortEntry := haCloseSmooth
    longEntry := na

if strategy.position_size > 0
    sl = longSL
    tp = longTP
    if useBE and not na(longEntry)
        reachedBE = (high >= longEntry + beRR * (longEntry - longSL))
        sl := reachedBE ? math.max(sl, beLongPrice) : sl
    if useTrail
        sl := math.max(sl, trailLong)
    strategy.exit("Long-Exit", from_entry="Long", stop=sl, limit=tp)

if strategy.position_size < 0
    sl = shortSL
    tp = shortTP
    if useBE and not na(shortEntry)
        reachedBE = (low <= shortEntry - beRR * (shortSL - shortEntry))
        sl := reachedBE ? math.min(sl, beShortPrice) : sl
    if useTrail
        sl := math.min(sl, trailShort)
    strategy.exit("Short-Exit", from_entry="Short", stop=sl, limit=tp)

//───────────────────────────────
// ⌥ Alerts
//───────────────────────────────
alertcondition(longCond,  title="Long Signal",  message="HA LONG on {{ticker}} @ {{close}}")
alertcondition(shortCond, title="Short Signal", message="HA SHORT on {{ticker}} @ {{close}}")

//───────────────────────────────
// ⌥ Pure HA Plot
//───────────────────────────────
plot(emaFast, "EMA Fast (HA)")
plot(emaSlow, "EMA Slow (HA)")
plot(vwap,    "VWAP")
plotcandle(haOpen, haHigh, haLow, haCloseSmooth, color=haCloseSmooth >= haOpen ? color.green : color.red, title="Heikin Ashi Candles")
plotshape(longCond,  title="Long ▲",  style=shape.triangleup,   location=location.belowbar, size=size.tiny, text="L")
plotshape(shortCond, title="Short ▼", style=shape.triangledown, location=location.abovebar, size=size.tiny, text="S")
